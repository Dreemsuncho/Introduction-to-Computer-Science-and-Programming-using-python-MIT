## Book exercises:

* #### Finger exercise 01.
    Write a program that examines three variables—x, y, and z—
    and prints the largest odd number among them. If none of them are odd, it
    should print a message to that effect.

* #### Finger exercise 02.
    Write a program that asks the user to input 10 integers, and
    then prints the largest odd number that was entered. If no odd number was
    entered, it should print a message to that effect.

* #### Finger exercise 03.
    Write a program that asks the user to enter an integer and
    prints two integers, root and pwr, such that 0 < pwr < 6 and root**pwr is equal
    to the integer entered by the user. If no such pair of integers exists, it should
    print a message to that effect.

* #### Finger exercise 04.
    Let s be a string that contains a sequence of decimal numbers
    separated by commas, e.g., s = '1.23,2.4,3.123'. Write a program that prints
    the sum of the numbers in s.

* #### Finger exercise 05.
    What would have to be changed to make the code in Figure 3.4 work for 
    finding an approximation to the cube root of both negative and positive numbers? 
    (Hint: think about changing low to ensure that the answer lies within the region being searched.)

* #### Finger exercise 06.
    Add some code to the implementation of Newton-Raphson that keeps track of the number of iterations used to find the root. Use that code as part of a program that compares the efficiency of Newton-Raphson and bisection search. (You should discover that Newton-Raphson is more efficient.)

* #### Finger exercise 07.
    Write a function isIn that accepts two strings as arguments and returns True if either string occurs anywhere in the other, and False otherwise. Hint: you might want to use the built-in str operation in.

* #### Finger exercise 08.
    Finger exercise: When the implementation of fib in Figure 4.7 is used to compute fib(5), how many times does it compute the value of fib(2) on the way to computing fib(5)?